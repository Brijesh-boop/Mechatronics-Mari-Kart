#Basic imports for library functions

#from picamzero import Camera
#from time import sleep
import RPi.GPIO as GPIO

import cv2
import numpy as np
from picamera2 import Picamera2
import time

# Initialize the camera
picam2 = Picamera2()
config = picam2.create_preview_configuration(main={"size": (1280, 720)})
picam2.configure(config)
picam2.start()

#Initialize PWM pins and distance pins
pin3 = 20
pin4 = 21
pin1 = 1
pin2 = 7

trig_pin = 9
echo_pin = 11

pwml = 13
pwmr = 12

#Set pints to in or out
GPIO.setmode(GPIO.BCM)

GPIO.setup(pin1, GPIO.OUT)
GPIO.setup(pin2, GPIO.OUT)
GPIO.setup(pin3, GPIO.OUT)
GPIO.setup(pin4, GPIO.OUT)

GPIO.setup(pwml, GPIO.OUT)
GPIO.setup(pwmr, GPIO.OUT)

GPIO.setup(trig_pin, GPIO.OUT)
GPIO.setup(echo_pin, GPIO.IN)

#Set object and define starting pwm
pwml = GPIO.PWM(pwml, 1000)
pwml.start(0)

pwmr = GPIO.PWM(pwmr, 1000)
pwmr.start(0)

# Define color ranges in HSV
# Yellow color range
hl = int(10) #range from 0 to 179 deg
sl = int(0 * 2.55) #range from 0 to 255 but plug in percentage
vl = int(40 * 2.55) # ^^

hu = int(80)
su = int(100 * 2.55)
vu = int(100 * 2.55)

yellow_lower = np.array([hl, sl, vl])
yellow_upper = np.array([hu, su, vu])

# Region of interest parameters
roi_height = 1.0  # Initial value set to %60, changed to 100% during testing
roi_top = int(720 * (1 - roi_height))

# Control parameters
target_yellow_height = 575
position_tolerance = 90  # pixels tolerance for target position

max_speed = 100
min_speed = 40
base_speed = 100 #Set PWM to always be max as our motors are slow

#End line detection box
end_box_width = 200
end_box_height = 500
end_box_x_offset = 0

def get_yellow_line_height(frame):
    """Detect yellow line position"""
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
   
    # Create mask for yellow
    yellow_mask = cv2.inRange(hsv, yellow_lower, yellow_upper)
   
    # Apply ROI - only look at bottom part of frame
    roi_mask = np.zeros_like(yellow_mask)
    roi_mask[roi_top:, :] = 255
   
    yellow_mask = cv2.bitwise_and(yellow_mask, roi_mask)
   
    # Find contours for yellow
    yellow_contours, _ = cv2.findContours(yellow_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
   
    yellow_height = None
    yellow_area = 0
    yellow_end = 0
   
    # Find yellow lane
    if yellow_contours:
        largest_yellow = max(yellow_contours, key=cv2.contourArea)
        yellow_area = cv2.contourArea(largest_yellow)
        if yellow_area > 100:  # Minimum area threshold
            bottom_point = largest_yellow[largest_yellow[:, :, 1].argmax()][0]
            yellow_height = bottom_point[1]
            
            frame_height, frame_width = frame.shape[:2]
            
	    #Set box frame to be masked and detected as well
            box_x = frame_width - end_box_width - end_box_x_offset
            box_y = yellow_height - end_box_height // 2
            
            box_x = max(0, box_x)
            box_y = max(0, min(box_y, frame_height - end_box_height))
            
            roi_right = frame[box_y:box_y + end_box_height, box_x:box_x + end_box_width]
            
            hsv_right = cv2.cvtColor(roi_right, cv2.COLOR_BGR2HSV)
            yellow_mask_right = cv2.inRange(hsv_right, yellow_lower, yellow_upper)
            
            #How much yellow is in the box?
            yellow_pixels = cv2.countNonZero(yellow_mask_right)
            total_pixels = end_box_width * end_box_height
            yellow_ratio = yellow_pixels / total_pixels
            
	    #If there is at least 1% yellow, then the line has not ended, anything less, there is a left turn ahead.
            if yellow_ratio > 0.01:
                yellow_end = 1
            else:
                yellow_end = 2
    return yellow_height, yellow_area, yellow_mask, yellow_end

def calculate_steering(yellow_height, yellow_area, frame_height):
    """Calculate steering command based on yellow line position"""
    
    # If we can't see the yellow line, turn left to search for it
    if yellow_height is None:
        return -0.5, "SEARCH_LEFT"
    
    # Calculate error from target position (how far yellow is from right side)
    error = target_yellow_height - yellow_height
    
    # Normalize error to steering command #NOTE: steering never ended up being used
    steering = np.clip(error / 200, -1.0, 1.0)
    
    if abs(error) < position_tolerance:
        return steering, "STRAIGHT"
    elif error > 0:
        return steering, "LEFT"
    else:
        return steering, "RIGHT"
    
def control_robot(steering, direction, yellow_end):
    """Convert steering command to motor controls"""  
    
    wall_distance = 40

    #direction  = "STRAIGHT" #uncomment this line to override all steering from camera, used to test the drive train
    turnP = .75 #Turn percentage can be adjusted to get more or less addressive turning
    
    if direction == "SEARCH_LEFT":
        GPIO.output(pin1, GPIO.LOW)
        GPIO.output(pin3, GPIO.HIGH)
        GPIO.output(pin2, GPIO.HIGH)
        GPIO.output(pin4, GPIO.LOW)
        
        pwml.ChangeDutyCycle(base_speed * turnP)
        pwmr.ChangeDutyCycle(base_speed)
        
    elif direction == "STRAIGHT":
        print("Straight")
        GPIO.output(pin1, GPIO.HIGH)
        GPIO.output(pin3, GPIO.HIGH)
        GPIO.output(pin2, GPIO.LOW)
        GPIO.output(pin4, GPIO.LOW)
        
        pwml.ChangeDutyCycle(100)
        pwmr.ChangeDutyCycle(100)
        
    elif direction == "LEFT":
        
        print("Left")
        GPIO.output(pin1, GPIO.LOW)
        GPIO.output(pin3, GPIO.HIGH)
        GPIO.output(pin2, GPIO.HIGH)
        GPIO.output(pin4, GPIO.LOW)
        
        pwml.ChangeDutyCycle(base_speed * turnP)
        pwmr.ChangeDutyCycle(base_speed)
        
    elif direction == "RIGHT":
        
        left_speed = base_speed
        right_speed = base_speed *turnP
        GPIO.output(pin1, GPIO.HIGH)
        GPIO.output(pin3, GPIO.LOW)
        GPIO.output(pin2, GPIO.LOW)
        GPIO.output(pin4, GPIO.HIGH)
        
        pwml.ChangeDutyCycle(left_speed)
        pwmr.ChangeDutyCycle(right_speed)        
        
def timedelay(seconds): #Custom millis function, did not end up implementing
    start_time = time.time()
    while time.time() - start_time < seconds:
        pass
        

#The following are custom wind up and down functions so the motors dont strip out the D Shaft profile of the gears when starting, stoping, or changing direction. 
#The Motors were too slow to do so in testing, functions were abondend for speed. 
def windup_both(seconds):
    
    microsteps = 1000
    
    timestep = seconds / microsteps
            
    GPIO.output(pin1, GPIO.HIGH)
    GPIO.output(pin3, GPIO.HIGH)
    GPIO.output(pin2, GPIO.LOW)
    GPIO.output(pin4, GPIO.LOW)
    
    for i in range(microsteps):
        pwml.ChangeDutyCycle(i/microsteps * 100)
        pwmr.ChangeDutyCycle(i/microsteps * 100)
        
        timedelay(timestep)

def winddown_both(seconds):
    
    microsteps = 1000
    
    timestep = seconds / microsteps
    
    GPIO.output(pin1, GPIO.HIGH)
    GPIO.output(pin3, GPIO.HIGH)
    GPIO.output(pin2, GPIO.LOW)
    GPIO.output(pin4, GPIO.LOW)
    
    for i in range(microsteps):
        pwml.ChangeDutyCycle((microsteps - i)/microsteps * 100)
        pwmr.ChangeDutyCycle((microsteps - i)/microsteps * 100)
        
        timedelay(timestep)
        

def windup_rl(seconds, D):
    
    microsteps = 1000
    
    timestep = seconds / microsteps
    GPIO.output(pin1, GPIO.HIGH)
    GPIO.output(pin3, GPIO.HIGH)
    GPIO.output(pin2, GPIO.LOW)
    GPIO.output(pin4, GPIO.LOW)
    
    for i in range(microsteps):
        if D == "r":
            
            pwmr.ChangeDutyCycle(i/microsteps * 100)
            timedelay(timestep)
        else:
            
            pwml.ChangeDutyCycle(i/microsteps * 100)
            timedelay(timestep)
            
def winddown_rl(seconds, D):
    
    microsteps = 1000
    
    timestep = seconds / microsteps
    
    GPIO.output(pin1, GPIO.HIGH)
    GPIO.output(pin3, GPIO.HIGH)
    GPIO.output(pin2, GPIO.LOW)
    GPIO.output(pin4, GPIO.LOW)
    
    for i in range(microsteps):
        if D == "r":
                    
            pwmr.ChangeDutyCycle((microsteps - i)/microsteps * 100)
            timedelay(timestep)
        else:
            
            pwml.ChangeDutyCycle((microsteps - i)/microsteps * 100)
            timedelay(timestep)

#Basic get distance function from ultrasonic sensor documention. Trigger pin activates the sensor for short ammount of time, then is distance is calcualted from echo pin. Function was also abonded due to time constraints.
def get_distance():
    
    GPIO.output(trig_pin, True)
    time.sleep(.00001)
    GPIO.output(trig_pin, False)
    
    while GPIO.input(echo_pin) == 0:
        pulse_start = time.time()
        
    while GPIO.input(echo_pin) == 1:
        pulse_end = time.time()
    
    duration = pulse_end - pulse_start
    distance = duration * 17150
    return distance

#Main loop
def main():
    print("Starting yellow line following...")
    print("Press 'q' to quit")
   
    try:
	#initial windup you see below never happens as the code was running for a while before the battery was connected during the race. 
        windup_both(1)
        while True:
            # Capture frame
            frame = picam2.capture_array()
            frame = cv2.flip(frame, -1) #Important to flip the camera as the camera was mounted upside down 

            
            # Convert BGR to RGB for OpenCV
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
           
            # Get yellow line position
            yellow_height, yellow_area, yellow_mask, yellow_end = get_yellow_line_height(frame)
           
            # Calculate steering
            steering, direction = calculate_steering(yellow_height, yellow_area, frame.shape[0])
            
            # Control robot
            control_robot(steering, direction, yellow_end)

            # Visualization
            frame_height = frame.shape[0]
            frame_width = frame.shape[1]
            
            # Draw target position line (right side)
            cv2.line(frame, (0, target_yellow_height), (frame_width, target_yellow_height), (0, 0, 255), 3)
           
            cv2.line(frame, (0, roi_top), (frame_width, roi_top), (255, 0, 0), 2)
           
            # Draw yellow line position if detected
            if yellow_height:
                cv2.line(frame, (0, yellow_height), (frame_width, yellow_height), (0, 255, 255), 3)
                cv2.putText(frame, f"Yellow: {yellow_height}", (10, 30), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
                           
           # Draw right edge detection box if yellow is detected
            if yellow_height is not None:
                box_x = frame_width - end_box_width - end_box_x_offset
                box_y = yellow_height - end_box_height // 2
                frame_height, frame_width = frame.shape[:2]
                box_y = max(0, min(box_y, frame_height - end_box_height))
                box_x = max(0, box_x)
                
                # Color box based on yellow_end status
                if yellow_end == 1:
                    box_color = (0, 255, 0)  # Green - line continues
                else:
                    box_color = (0, 0, 255)  # Red - line ending
                    
                cv2.rectangle(frame, (box_x, box_y), 
                             (box_x + end_box_width, box_y + end_box_height), 
                             box_color, 2)
           
            # Target position
            cv2.putText(frame, f"Target: {target_yellow_height}", (10, 60), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                       
             # Display direction
            cv2.putText(frame, f"Direction: {direction}", (10, 90), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)          
            # Display
            cv2.imshow('Yellow Line Following', frame)
            #cv2.imshow('Yellow Mask', yellow_mask)
           
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
               
            time.sleep(0.05)  # Control loop frequency
           
    except KeyboardInterrupt:
        print("Stopping...")
   
    finally:
        cv2.destroyAllWindows()
        picam2.stop()
        GPIO.cleanup()

if __name__ == "__main__":
    main()